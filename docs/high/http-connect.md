## HTTP(S)连接
### http发起连接三次握手
* 客户端： 我要请求服务端，然后发个SYN包给客户端，看它反应
* 服务端： 我收到了客户端的SYN包，知道了它要请求我，得回应他下，我现在有空，可以给你发数据
* 客户端： 好好，收到回应很开心，我马上发数据给你啊(这步主要避免服务端过长时间等待)  
。。。通信中

### http关闭连接四次握手
* 客户端：我没其他请求了，然后发个FIN包给服务端，告诉它要关闭连接
* 服务端：收到客户端的FIN包，立刻明白客户端的意思，得回应他下，收到消息
* 服务端：又想了一下，千辛万苦建立的连接真要断吗，再问下客户端，你是要关闭连接吗
* 客户端：是的，我不用了，已经确认，请关闭吧
* 服务端： 关闭该连接

### 图示
![](https://upload-images.jianshu.io/upload_images/10649427-8f3a8e44af4f48b0?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)

### https
#### why
**http明文传输，会点技术的都可以看到我，篡改我传输的信息，不安全**

于是设计者又设计了高招，加个安全套接层ssl。国际大佬看到这个ssl不错，于是把它稍微修改，引入了标准里并改了个名字TLS.
https = http + ssl/tls

#### 流程
* 基础是http，那先完成三次握手
* 客户端： 发给服务端支持的协议ssl/tls
* 服务端： 哦，原来你这次这个啊，那我选择个合适的
* 服务端： 准备好了，再发给你证书，证书里有公钥
* 客户端： 我随机生成个随机对称秘钥，再用公钥加密一下，发给服务端
* 服务端： 我用私钥解密，获取里面的随机对称秘钥
* 服务端： 用对称秘钥加密数据，并发给客户端
* 客户端： 收到数据，用对称秘钥解密，建立通信
![](http://7xs4tc.com1.z0.glb.clouddn.com/httpsCreat.png)
